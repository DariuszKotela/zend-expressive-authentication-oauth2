{
    "docs": [
        {
            "location": "/",
            "text": "OAuth2 server middleware for Expressive and PSR-7 applications\n\n\n\n\n\n\nZend-expressive-authentication-oauth2 is middleware for \nExpressive\n\nand \nPSR-7\n applications providing an OAuth2\nserver for authentication.\n\n\nThis library uses the \nleague/oauth2-server\n\npackage for implementing the OAuth2 server. It supports all the following grant\ntypes:\n\n\n\n\nclient credentials;\n\n\npassword;\n\n\nauthorization code;\n\n\nimplicit;\n\n\nrefresh token;\n\n\n\n\nWORK IN PROGRESS\n\n\nThis repository contains a \nwork in progress\n project for building an\nauthentication module for Expressive and PSR-7 applications.\nIt also provides an OAuth2 adapter for \nzend-expressive-authentication\n\nlibrary.\n\n\nPlease, don't use this code in a production environment!\n\n\nInstallation\n\n\nYou can install the \nzend-expressive-authentication-oauth2\n library with\ncomposer:\n\n\n$ composer require zendframework/zend-expressive-authentication-oauth2\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "OAuth2 server middleware for Expressive and PSR-7 applications"
        },
        {
            "location": "/#oauth2-server-middleware-for-expressive-and-psr-7-applications",
            "text": "Zend-expressive-authentication-oauth2 is middleware for  Expressive \nand  PSR-7  applications providing an OAuth2\nserver for authentication.  This library uses the  league/oauth2-server \npackage for implementing the OAuth2 server. It supports all the following grant\ntypes:   client credentials;  password;  authorization code;  implicit;  refresh token;",
            "title": "OAuth2 server middleware for Expressive and PSR-7 applications"
        },
        {
            "location": "/#work-in-progress",
            "text": "This repository contains a  work in progress  project for building an\nauthentication module for Expressive and PSR-7 applications.\nIt also provides an OAuth2 adapter for  zend-expressive-authentication \nlibrary.  Please, don't use this code in a production environment!",
            "title": "WORK IN PROGRESS"
        },
        {
            "location": "/#installation",
            "text": "You can install the  zend-expressive-authentication-oauth2  library with\ncomposer:  $ composer require zendframework/zend-expressive-authentication-oauth2",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "zendframework/zend-expressive-authentication-oauth2\n\n\nThis component provides \nOAuth2\n (server) authentication\nfor \nExpressive\n and\n\nPSR-7\n applications. It implements\n\nZend\\Expressive\\Authentication\\AuthenticationInterface\n, and it be used as\nan adapter for \nzend-expressive-authentication\n.\n\n\nThis library uses the \nleague/oauth2-server\n\npackage for implementing the OAuth2 server.\n\n\nIf you need an introduction to OAuth2, you can read the following references:\n\n\n\n\nOAuth2 documentation\n\n  from the Apigility project.\n\n\nAn Introduction to OAuth 2\n\n  by Digital Ocean.\n\n\nThe \nOAuth2 specification\n itself, via its official\n  website.\n\n\n\n\nInstallation\n\n\nIn order to implement the OAuth2 server, we first need to configure it. The\nfirst step is to generate new cryptographic keys. We need to execute the script\n\nbin/generate-oauth2-keys\n in order to generate these keys.\n\n\n$ ./vendor/bin/generate-oauth2-keys\n\n\n\nThis script will store the keys in the parent application \ndata\n folder if found:\n\n\nPrivate key stored in:\n./data/oauth/private.key\nPublic key stored in:\n./data/oauth/public.key\nEncryption key stored in:\n./data/oauth/encryption.key\n\n\n\nThe script will generate public and private keys, and an encryption key.\nThese keys are used by \nleague/oauth2-server\n\nas security settings for the OAuth2 server infrastructure.\n\n\nConfiguration\n\n\nThe OAuth2 server is configured by the \nauthentication\n configuration key in the\nPSR-11 container (e.g. \nzend-servicemanager\n).\n\n\nThe default values are:\n\n\nreturn [\n    'private_key'    => __DIR__ . '/../data/oauth/private.key',\n    'public_key'     => __DIR__ . '/../data/oauth/public.key',\n    'encryption_key' => require __DIR__ . '/../data/oauth/encryption.key',\n    'access_token_expire'  => 'P1D',\n    'refresh_token_expire' => 'P1M',\n    'auth_code_expire'     => 'PT10M',\n    'pdo' => [\n        'dsn'      => '',\n        'username' => '',\n        'password' => ''\n    ],\n\n    // Set value to null to disable a grant\n    'grants' => [\n        \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\PasswordGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\PasswordGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\ImplicitGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\ImplicitGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant::class\n    ],\n];\n\n\n\nThe \nprivate_key\n and \npublic_key\n values contains the paths to the previous\ngenerated pair of keys. The \nencryption_key\n contains the encryption key value\nas a string, as stored in the \ndata/oauth/encryption.key\n file.\n\n\nThe \naccess_token_expire\n value is the time-to-live (TTL) value of the access\ntoken. The time period is represented using the \nDateInterval\n\nformat in PHP.  The default value is \nP1D\n (1 day).\n\n\nThe \nrefresh_token_expire\n value is the TTL used for the refresh token. The\ndefault value is 1 month.\n\n\nThe \nauth_code_expire\n value is the TTL of the authentication code, used in\nthe \nauthorization code grant\n\nscenario. The default value is 10 minutes.\n\n\nThe \npdo\n value is for the PDO database configuration. Here we need to insert\nthe parameters to access the OAuth2 database. These parameters are the \ndsn\n,\nthe \nusername\n, and the \npassword\n, if required. The SQL structure of this\ndatabase is stored in the \ndata/oauth2.sql\n\nfile.\n\n\nThe \ngrants\n array is for enabling/disabling grants.   By default all the supported\ngrants are configured to be available.  If you would like to disable any of the \nsupplied grants, simply change the value for the grant to NULL.  Additionally,\nyou can extend this array to add your own custom grants. \n\n\nYou need to provide an OAuth2 database yourself, or generate a \nSQLite\n\ndatabase with the following command (using \nsqlite3\n for GNU/Linux):\n\n\n$ sqlite3 data/oauth2.sqlite < data/oauth2.sql\n\n\n\nYou can also create some testing values using the \ndata/oauth2_test.sql\n file:\n\n\n$ sqlite3 data/oauth2.sqlite < data/oauth2_test.sql\n\n\n\nThese commands will insert the following testing values:\n\n\n\n\na client \nclient_test\n with secret \ntest\n, used for \nclient_credentials\n\n  and the \npassword\n grant type.\n\n\na client \nclient_test2\n with secret \ntest\n, used for \nauthorization code\n\n  and \nimplicit\n grant type.\n\n\na user \nuser_test\n with password \ntest\n.\n\n\na \ntest\n scope.\n\n\n\n\nFor security reason, the client \nsecret\n and the user \npassword\n are stored\nusing the \nbcrypt\n algorithm provided by \npassword_hash\n\nfunction of PHP.\n\n\nConfigure the OAuth2 route\n\n\nAs last step, in order to use the OAuth2 server you need to configure a route\nto point to \nZend\\Expressive\\Authentication\\OAuth2\\OAuth2Middleware\n with\nGET and POST HTTP verbs.\n\n\nFor instance, you can add the following route to your Expressive application:\n\n\n$app->route(\n    '/oauth',\n    Zend\\Expressive\\Authentication\\OAuth2\\OAuth2Middleware::class,\n    ['GET', 'POST'],\n    'oauth'\n);\n\n\n\nWith this configuration, you can interact with the OAuth2 server using \n/oauth\n\nURL.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#zendframeworkzend-expressive-authentication-oauth2",
            "text": "This component provides  OAuth2  (server) authentication\nfor  Expressive  and PSR-7  applications. It implements Zend\\Expressive\\Authentication\\AuthenticationInterface , and it be used as\nan adapter for  zend-expressive-authentication .  This library uses the  league/oauth2-server \npackage for implementing the OAuth2 server.  If you need an introduction to OAuth2, you can read the following references:   OAuth2 documentation \n  from the Apigility project.  An Introduction to OAuth 2 \n  by Digital Ocean.  The  OAuth2 specification  itself, via its official\n  website.",
            "title": "zendframework/zend-expressive-authentication-oauth2"
        },
        {
            "location": "/intro/#installation",
            "text": "In order to implement the OAuth2 server, we first need to configure it. The\nfirst step is to generate new cryptographic keys. We need to execute the script bin/generate-oauth2-keys  in order to generate these keys.  $ ./vendor/bin/generate-oauth2-keys  This script will store the keys in the parent application  data  folder if found:  Private key stored in:\n./data/oauth/private.key\nPublic key stored in:\n./data/oauth/public.key\nEncryption key stored in:\n./data/oauth/encryption.key  The script will generate public and private keys, and an encryption key.\nThese keys are used by  league/oauth2-server \nas security settings for the OAuth2 server infrastructure.",
            "title": "Installation"
        },
        {
            "location": "/intro/#configuration",
            "text": "The OAuth2 server is configured by the  authentication  configuration key in the\nPSR-11 container (e.g.  zend-servicemanager ).  The default values are:  return [\n    'private_key'    => __DIR__ . '/../data/oauth/private.key',\n    'public_key'     => __DIR__ . '/../data/oauth/public.key',\n    'encryption_key' => require __DIR__ . '/../data/oauth/encryption.key',\n    'access_token_expire'  => 'P1D',\n    'refresh_token_expire' => 'P1M',\n    'auth_code_expire'     => 'PT10M',\n    'pdo' => [\n        'dsn'      => '',\n        'username' => '',\n        'password' => ''\n    ],\n\n    // Set value to null to disable a grant\n    'grants' => [\n        \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\PasswordGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\PasswordGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\AuthCodeGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\ImplicitGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\ImplicitGrant::class,\n        \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant::class\n            => \\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant::class\n    ],\n];  The  private_key  and  public_key  values contains the paths to the previous\ngenerated pair of keys. The  encryption_key  contains the encryption key value\nas a string, as stored in the  data/oauth/encryption.key  file.  The  access_token_expire  value is the time-to-live (TTL) value of the access\ntoken. The time period is represented using the  DateInterval \nformat in PHP.  The default value is  P1D  (1 day).  The  refresh_token_expire  value is the TTL used for the refresh token. The\ndefault value is 1 month.  The  auth_code_expire  value is the TTL of the authentication code, used in\nthe  authorization code grant \nscenario. The default value is 10 minutes.  The  pdo  value is for the PDO database configuration. Here we need to insert\nthe parameters to access the OAuth2 database. These parameters are the  dsn ,\nthe  username , and the  password , if required. The SQL structure of this\ndatabase is stored in the  data/oauth2.sql \nfile.  The  grants  array is for enabling/disabling grants.   By default all the supported\ngrants are configured to be available.  If you would like to disable any of the \nsupplied grants, simply change the value for the grant to NULL.  Additionally,\nyou can extend this array to add your own custom grants.   You need to provide an OAuth2 database yourself, or generate a  SQLite \ndatabase with the following command (using  sqlite3  for GNU/Linux):  $ sqlite3 data/oauth2.sqlite < data/oauth2.sql  You can also create some testing values using the  data/oauth2_test.sql  file:  $ sqlite3 data/oauth2.sqlite < data/oauth2_test.sql  These commands will insert the following testing values:   a client  client_test  with secret  test , used for  client_credentials \n  and the  password  grant type.  a client  client_test2  with secret  test , used for  authorization code \n  and  implicit  grant type.  a user  user_test  with password  test .  a  test  scope.   For security reason, the client  secret  and the user  password  are stored\nusing the  bcrypt  algorithm provided by  password_hash \nfunction of PHP.",
            "title": "Configuration"
        },
        {
            "location": "/intro/#configure-the-oauth2-route",
            "text": "As last step, in order to use the OAuth2 server you need to configure a route\nto point to  Zend\\Expressive\\Authentication\\OAuth2\\OAuth2Middleware  with\nGET and POST HTTP verbs.  For instance, you can add the following route to your Expressive application:  $app->route(\n    '/oauth',\n    Zend\\Expressive\\Authentication\\OAuth2\\OAuth2Middleware::class,\n    ['GET', 'POST'],\n    'oauth'\n);  With this configuration, you can interact with the OAuth2 server using  /oauth \nURL.",
            "title": "Configure the OAuth2 route"
        },
        {
            "location": "/usage/",
            "text": "Usage\n\n\nIf you successfully configured the OAuth2 server as detailed in the\n\ninstallation\n section, you can request an access token using the\nOAuth2 server route defined \nbefore\n\n(e.g. \n/oauth\n).\n\n\nYou can require an access token using one of the following scenarios:\n\n\n\n\nclient credentials\n;\n\n\npassword\n;\n\n\nauthorization code\n;\n\n\nimplicit\n;\n\n\nrefresh token\n.\n\n\n\n\nAuthenticate a middleware\n\n\nThis library uses the authentication abstraction of the \nZend\\Expressive\\Authentication\\AuthenticationMiddleware\n\nclass provided by \nzend-expressive-authentication\n.\n\n\nIn order to use OAuth2 we need to configure the service\n\nZend\\Expressive\\Authentication\\AuthenticationInterface\n to resolve in\n\nZend\\Expressive\\Authentication\\OAuth2\\OAuth2Adapter\n. Using the\n\nzend-servicemanager\n this\ncan be achieved using \naliases\n with the following configuration:\n\n\nuse Zend\\Expressive\\Authentication;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            Authentication\\AuthenticationInterface::class => Authentication\\OAuth2\\OAuth2Adapter::class,\n        ],\n    ],\n];\n\n\n\nThe previous configuration will instruct \nzend-expressive-authentication\n to use\nthe OAuth2 adapter. This adapter does not require a \nZend\\Expressive\\Authentication\\UserRepositoryInterface\n.\nThe OAuth2 database with user and client credentials is managed by the component\nitself.\n\n\nWhen the service alias is configured, you can immediately begin authenticating\nyour application/API by adding the \nAuthenticationMiddleware\n to either your\napplication or route-specific middleware pipeline. For instance, using an\n\nExpressive\n application, you\ncould add it to a specific route, as follows:\n\n\n$app->post('/api/users', [\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Action\\AddUserAction::class,\n], 'api.add.user');",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage",
            "text": "If you successfully configured the OAuth2 server as detailed in the installation  section, you can request an access token using the\nOAuth2 server route defined  before \n(e.g.  /oauth ).  You can require an access token using one of the following scenarios:   client credentials ;  password ;  authorization code ;  implicit ;  refresh token .",
            "title": "Usage"
        },
        {
            "location": "/usage/#authenticate-a-middleware",
            "text": "This library uses the authentication abstraction of the  Zend\\Expressive\\Authentication\\AuthenticationMiddleware \nclass provided by  zend-expressive-authentication .  In order to use OAuth2 we need to configure the service Zend\\Expressive\\Authentication\\AuthenticationInterface  to resolve in Zend\\Expressive\\Authentication\\OAuth2\\OAuth2Adapter . Using the zend-servicemanager  this\ncan be achieved using  aliases  with the following configuration:  use Zend\\Expressive\\Authentication;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            Authentication\\AuthenticationInterface::class => Authentication\\OAuth2\\OAuth2Adapter::class,\n        ],\n    ],\n];  The previous configuration will instruct  zend-expressive-authentication  to use\nthe OAuth2 adapter. This adapter does not require a  Zend\\Expressive\\Authentication\\UserRepositoryInterface .\nThe OAuth2 database with user and client credentials is managed by the component\nitself.  When the service alias is configured, you can immediately begin authenticating\nyour application/API by adding the  AuthenticationMiddleware  to either your\napplication or route-specific middleware pipeline. For instance, using an Expressive  application, you\ncould add it to a specific route, as follows:  $app->post('/api/users', [\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Action\\AddUserAction::class,\n], 'api.add.user');",
            "title": "Authenticate a middleware"
        },
        {
            "location": "/grant/client_credentials/",
            "text": "Client credentials\n\n\nThe client credentials grant is used in machine-to-machine scenarios: for\nexample, a client making API requests that do not require a user's permission.\n\n\nThe client sends a \nPOST\n request with following body parameters to the\nauthorization server:\n\n\n\n\ngrant_type\n = client_credentials.\n\n\nclient_id\n with the client's ID.\n\n\nclient_secret\n with the client's secret.\n\n\nscope\n with a space-delimited list of requested scope permissions.\n\n\n\n\nThe authorization server responds with a JSON payload as follows:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe values returned are as follows:\n\n\n\n\nThe \ntoken_type\n is the type of generated token (here, and generally, Bearer).\n\n\nexpires_in\n is an integer representing the time-to-live (in seconds) of the\n  access token.\n\n\nThe \naccess_token\n contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n  \nAuthorization\n request HTTP header in subsequent requests.",
            "title": "Client credentials"
        },
        {
            "location": "/grant/client_credentials/#client-credentials",
            "text": "The client credentials grant is used in machine-to-machine scenarios: for\nexample, a client making API requests that do not require a user's permission.  The client sends a  POST  request with following body parameters to the\nauthorization server:   grant_type  = client_credentials.  client_id  with the client's ID.  client_secret  with the client's secret.  scope  with a space-delimited list of requested scope permissions.   The authorization server responds with a JSON payload as follows:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The values returned are as follows:   The  token_type  is the type of generated token (here, and generally, Bearer).  expires_in  is an integer representing the time-to-live (in seconds) of the\n  access token.  The  access_token  contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n   Authorization  request HTTP header in subsequent requests.",
            "title": "Client credentials"
        },
        {
            "location": "/grant/password/",
            "text": "Password\n\n\nThis use case can be used to authenticate an API with user's password grant.\nThe typical scenario includes a Login web page with username and password that\nis used to authenticate against a first-party API. Password grant is only\nappropriate for \ntrusted clients\n. If you build your own website as a client\nof your API, then this is a great way to handle logging in.\n\n\nThe client sends a POST request with following parameters:\n\n\n\n\ngrant_type\n = password;\n\n\nclient_id\n with the client\u2019s ID;\n\n\nclient_secret\n with the client\u2019s secret;\n\n\nscope\n with a space-delimited list of requested scope permissions;\n\n\nusername\n with the user\u2019s username;\n\n\npassword\n with the user\u2019s password.\n\n\n\n\nThe authorization server responds with a JSON as follows:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe \ntoken_type\n is the type of generated token (Bearer). The \nexpires_in\n is\nan integer representing the TTL (in seconds) of the access token.\nThe \nrefresh_token\n a token that can be used to refresh the \naccess_token\n when\nexpired.\nThe \naccess_token\n contains a \nJWT\n signed with the authorization server\u2019s\nprivate key. This token must be used in the \nAuthorization\n request HTTP header.",
            "title": "Password"
        },
        {
            "location": "/grant/password/#password",
            "text": "This use case can be used to authenticate an API with user's password grant.\nThe typical scenario includes a Login web page with username and password that\nis used to authenticate against a first-party API. Password grant is only\nappropriate for  trusted clients . If you build your own website as a client\nof your API, then this is a great way to handle logging in.  The client sends a POST request with following parameters:   grant_type  = password;  client_id  with the client\u2019s ID;  client_secret  with the client\u2019s secret;  scope  with a space-delimited list of requested scope permissions;  username  with the user\u2019s username;  password  with the user\u2019s password.   The authorization server responds with a JSON as follows:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The  token_type  is the type of generated token (Bearer). The  expires_in  is\nan integer representing the TTL (in seconds) of the access token.\nThe  refresh_token  a token that can be used to refresh the  access_token  when\nexpired.\nThe  access_token  contains a  JWT  signed with the authorization server\u2019s\nprivate key. This token must be used in the  Authorization  request HTTP header.",
            "title": "Password"
        },
        {
            "location": "/grant/auth_code/",
            "text": "Authorization code\n\n\nThe authorization code is used to authenticate a web application with a\nthird-party service (e.g., imagine you built a web application that needs to\nconsume the API of Facebook). You can authenticate your application using the\nthird-party server with a 4-step flow as illustrated in this diagram:\n\n\n\n\nThe web application sends a request (including the \nclient_id\n and the\n\nredirect_uri\n) to the authorization server asking for an Authorization code (1).\nThe authorization server shows an Allow/Deny page to the end-user requesting\nauthorization for access. If the user clicks on \"Allow\", the server sends the\nauthorization code to the web application using the \nredirect_uri\n (2).\nThe web application can now perform a token request, passing the \nclient_id\n,\nthe \nredirect_uri\n, the \nclient_secret\n, and the authentication code to prove\nthat it is authorized to perform the request (3). The authorization server sends\nthe access token in response if the request is valid (4).\n\n\nRequest the authorization code\n\n\nThe client sends the following parameters via query string arguments to the\nauthorization server:\n\n\n\n\nresponse_type\n = code.\n\n\nclient_id\n with the client identifer.\n\n\nredirect_uri\n with the URI to which to redirect the client following\n  successful authorization. This parameter is optional, but if it is not sent,\n  the user will be redirected to a default location on completion.\n\n\nscope\n with a space-delimited list of requested scope permissions.\n\n\nstate\n with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional, but highly recommended.  You can store the value of the CSRF token in\n  the user\u2019s session to be validated in the next step.\n\n\n\n\nThe user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request they will be redirected to the\nredirect URI with the following parameters in the query string arguments:\n\n\n\n\ncode\n with the authorization code.\n\n\nstate\n with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.\n\n\n\n\nRequest the access token\n\n\nThe client sends a POST request to the authorization server with the following\nparameters:\n\n\n\n\ngrant_type\n = authorization_code.\n\n\nclient_id\n with the client\u2019s ID.\n\n\nclient_secret\n with the client\u2019s secret.\n\n\nredirect_uri\n with the previous client redirect URI.\n\n\ncode\n with the authorization code as returned in the authorization code\n  request (as detailed in the previous section).\n\n\n\n\nThe authorization server responds with a JSON payload similar to the following:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe values are as follows:\n\n\n\n\nThe \ntoken_type\n is the type of generated token (here, and generally,\n  \"Bearer\").\n\n\nThe \nexpires_in\n value is an integer representing the time-to-live (in\n  seconds) of the access token.\n\n\nThe \nrefresh_token\n is a token that can be used to refresh the \naccess_token\n\n  when expired.\n\n\nThe \naccess_token\n contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n  \nAuthorization\n request HTTP header on subsequent requests.",
            "title": "Authorization code"
        },
        {
            "location": "/grant/auth_code/#authorization-code",
            "text": "The authorization code is used to authenticate a web application with a\nthird-party service (e.g., imagine you built a web application that needs to\nconsume the API of Facebook). You can authenticate your application using the\nthird-party server with a 4-step flow as illustrated in this diagram:   The web application sends a request (including the  client_id  and the redirect_uri ) to the authorization server asking for an Authorization code (1).\nThe authorization server shows an Allow/Deny page to the end-user requesting\nauthorization for access. If the user clicks on \"Allow\", the server sends the\nauthorization code to the web application using the  redirect_uri  (2).\nThe web application can now perform a token request, passing the  client_id ,\nthe  redirect_uri , the  client_secret , and the authentication code to prove\nthat it is authorized to perform the request (3). The authorization server sends\nthe access token in response if the request is valid (4).",
            "title": "Authorization code"
        },
        {
            "location": "/grant/auth_code/#request-the-authorization-code",
            "text": "The client sends the following parameters via query string arguments to the\nauthorization server:   response_type  = code.  client_id  with the client identifer.  redirect_uri  with the URI to which to redirect the client following\n  successful authorization. This parameter is optional, but if it is not sent,\n  the user will be redirected to a default location on completion.  scope  with a space-delimited list of requested scope permissions.  state  with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional, but highly recommended.  You can store the value of the CSRF token in\n  the user\u2019s session to be validated in the next step.   The user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request they will be redirected to the\nredirect URI with the following parameters in the query string arguments:   code  with the authorization code.  state  with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.",
            "title": "Request the authorization code"
        },
        {
            "location": "/grant/auth_code/#request-the-access-token",
            "text": "The client sends a POST request to the authorization server with the following\nparameters:   grant_type  = authorization_code.  client_id  with the client\u2019s ID.  client_secret  with the client\u2019s secret.  redirect_uri  with the previous client redirect URI.  code  with the authorization code as returned in the authorization code\n  request (as detailed in the previous section).   The authorization server responds with a JSON payload similar to the following:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The values are as follows:   The  token_type  is the type of generated token (here, and generally,\n  \"Bearer\").  The  expires_in  value is an integer representing the time-to-live (in\n  seconds) of the access token.  The  refresh_token  is a token that can be used to refresh the  access_token \n  when expired.  The  access_token  contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n   Authorization  request HTTP header on subsequent requests.",
            "title": "Request the access token"
        },
        {
            "location": "/grant/implicit/",
            "text": "Implicit grant\n\n\nThe implicit grant is similar to the \nauthorization code\n grant,\nwith two differences: it's used for user-agent-based clients (e.g. single page\napplications) that cannot store a secret in a secure way; additionally, the\nauthorization server returns the access token directly, without the need of an\nauthorization code.\n\n\nThe client sends the following parameter via a query string argument to the\nauthorization server:\n\n\n\n\nresponse_type\n = token.\n\n\nclient_id\n, with the client\u2019s ID.\n\n\nredirect_uri\n, with the URI to which to redirect the client after completing\n  authorization. This parameter is optional; if not provided, however, the user\n  will be redirected to a default location.\n\n\nscope\n, with a space-delimited list of requested scope permissions.\n\n\nstate\n, with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional but highly recommended. You can store the value of CSRF token in the\n  user\u2019s session to be validated in the next step.\n\n\n\n\nThe user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request they will be redirected to the\nredirect URI with the following parameters in the query string arguments:\n\n\n\n\ntoken_type\n = Bearer.\n\n\nexpires_in\n, an integer representing the time-to-live (in seconds) of the\n  access token.\n\n\naccess_token\n, the access token represented by a JSON Web Token (JWT) signed\n  with the authorization server\u2019s private key.\n\n\nstate\n, with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.\n\n\n\n\nRefresh tokens are not to be issued for \nimplicit\n grants. This is a security\nrestriction coming from the OAuth2 specification, \nRFC 6749\n.",
            "title": "Implicit"
        },
        {
            "location": "/grant/implicit/#implicit-grant",
            "text": "The implicit grant is similar to the  authorization code  grant,\nwith two differences: it's used for user-agent-based clients (e.g. single page\napplications) that cannot store a secret in a secure way; additionally, the\nauthorization server returns the access token directly, without the need of an\nauthorization code.  The client sends the following parameter via a query string argument to the\nauthorization server:   response_type  = token.  client_id , with the client\u2019s ID.  redirect_uri , with the URI to which to redirect the client after completing\n  authorization. This parameter is optional; if not provided, however, the user\n  will be redirected to a default location.  scope , with a space-delimited list of requested scope permissions.  state , with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional but highly recommended. You can store the value of CSRF token in the\n  user\u2019s session to be validated in the next step.   The user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request they will be redirected to the\nredirect URI with the following parameters in the query string arguments:   token_type  = Bearer.  expires_in , an integer representing the time-to-live (in seconds) of the\n  access token.  access_token , the access token represented by a JSON Web Token (JWT) signed\n  with the authorization server\u2019s private key.  state , with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.   Refresh tokens are not to be issued for  implicit  grants. This is a security\nrestriction coming from the OAuth2 specification,  RFC 6749 .",
            "title": "Implicit grant"
        },
        {
            "location": "/grant/refresh_token/",
            "text": "Refresh token\n\n\nThe OAuth2 framework provides the ability to \nrefresh\n the access token,\ngenerating a new one with a new lifetime. This action can be performed using\nthe \nrefresh_token\n value, if present in the access token response.\n\n\nTo request a token refresh, the client needs to send a \nPOST\n request with\nthe following parameters:\n\n\n\n\ngrant_type\n = refresh_token.\n\n\nrefresh_token\n with the refresh token.\n\n\nclient_id\n with the client\u2019s ID.\n\n\nclient_secret\n with the client\u2019s secret.\n\n\nscope\n with a space-delimited list of requested scope permissions. This is\n  optional; if not sent, the original scopes will be used. Otherwise you can\n  request a \nreduced\n scope; you may never \nexpand\n scope during a refresh\n  operation.\n\n\n\n\nThe authorization server responds with a JSON payload as follows:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe values are as follows:\n\n\n\n\nThe \ntoken_type\n is the type of generated token (here, and generally, Bearer).\n\n\nexpires_in\n is an integer representing the time-to-live (in seconds) of the\n  access token.\n\n\nThe \nrefresh_token\n a token that can be used to refresh the \naccess_token\n\n  when expired.\n\n\nThe \naccess_token\n contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n  \nAuthorization\n request HTTP header on all subsequent requests.",
            "title": "Refresh token"
        },
        {
            "location": "/grant/refresh_token/#refresh-token",
            "text": "The OAuth2 framework provides the ability to  refresh  the access token,\ngenerating a new one with a new lifetime. This action can be performed using\nthe  refresh_token  value, if present in the access token response.  To request a token refresh, the client needs to send a  POST  request with\nthe following parameters:   grant_type  = refresh_token.  refresh_token  with the refresh token.  client_id  with the client\u2019s ID.  client_secret  with the client\u2019s secret.  scope  with a space-delimited list of requested scope permissions. This is\n  optional; if not sent, the original scopes will be used. Otherwise you can\n  request a  reduced  scope; you may never  expand  scope during a refresh\n  operation.   The authorization server responds with a JSON payload as follows:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The values are as follows:   The  token_type  is the type of generated token (here, and generally, Bearer).  expires_in  is an integer representing the time-to-live (in seconds) of the\n  access token.  The  refresh_token  a token that can be used to refresh the  access_token \n  when expired.  The  access_token  contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n   Authorization  request HTTP header on all subsequent requests.",
            "title": "Refresh token"
        }
    ]
}