{
    "docs": [
        {
            "location": "/",
            "text": "OAuth2 server middleware for Expressive and PSR-7 applications\n\n\n\n\n\n\nZend-expressive-authentication-oauth2 is middleware for \nExpressive\n\nand \nPSR-7\n applications providing an OAuth2\nserver for authentication.\n\n\nThis library uses the \nleague/oauth2-server\n\npackage for implementing the OAuth2 server. It supports all the following grant\ntypes:\n\n\n\n\nclient credentials;\n\n\npassword;\n\n\nauthorization code;\n\n\nimplicit;\n\n\nrefresh token;\n\n\n\n\nWORK IN PROGRESS\n\n\nThis repository contains a \nwork in progress\n project for building an\nauthentication module for Expressive and PSR-7 applications.\nIt also provides an OAuth2 adapter for \nzend-expressive-authentication\n\nlibrary.\n\n\nPlease, don't use this code in a production environment!\n\n\nInstallation\n\n\nYou can install the \nzend-expressive-authentication-oauth2\n library with\ncomposer:\n\n\n$ composer require zendframework/zend-expressive-authentication-oauth2\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "OAuth2 server middleware for Expressive and PSR-7 applications"
        },
        {
            "location": "/#oauth2-server-middleware-for-expressive-and-psr-7-applications",
            "text": "Zend-expressive-authentication-oauth2 is middleware for  Expressive \nand  PSR-7  applications providing an OAuth2\nserver for authentication.  This library uses the  league/oauth2-server \npackage for implementing the OAuth2 server. It supports all the following grant\ntypes:   client credentials;  password;  authorization code;  implicit;  refresh token;",
            "title": "OAuth2 server middleware for Expressive and PSR-7 applications"
        },
        {
            "location": "/#work-in-progress",
            "text": "This repository contains a  work in progress  project for building an\nauthentication module for Expressive and PSR-7 applications.\nIt also provides an OAuth2 adapter for  zend-expressive-authentication \nlibrary.  Please, don't use this code in a production environment!",
            "title": "WORK IN PROGRESS"
        },
        {
            "location": "/#installation",
            "text": "You can install the  zend-expressive-authentication-oauth2  library with\ncomposer:  $ composer require zendframework/zend-expressive-authentication-oauth2",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/v1/intro/",
            "text": "zendframework/zend-expressive-authentication-oauth2\n\n\nThis component provides \nOAuth2\n (server) authentication\nfor \nExpressive\n and\n\nPSR-7\n/\nPSR-15\n\napplications. It implements \nZend\\Expressive\\Authentication\\AuthenticationInterface\n,\nand it can be used as an adapter for \nzend-expressive-authentication\n.\n\n\nThis library uses the \nleague/oauth2-server\n\npackage for implementing the OAuth2 server.\n\n\nIf you need an introduction to OAuth2, you can read the following references:\n\n\n\n\nOAuth2 documentation\n\n  from the Apigility project.\n\n\nAn Introduction to OAuth 2\n\n  by DigitalOcean.\n\n\nThe \nOAuth2 specification\n itself, via its official\n  website.\n\n\n\n\nInstallation\n\n\nIn order to implement the OAuth2 server, we first need to configure it. The\nfirst step is to generate new cryptographic keys. We need to execute the script\n\n./vendor/bin/generate-oauth2-keys\n in order to generate these keys.\n\n\n$ ./vendor/bin/generate-oauth2-keys\n\n\n\nThis script will store the keys in the application's \ndata\n folder if found:\n\n\nPrivate key stored in:\n./data/oauth/private.key\nPublic key stored in:\n./data/oauth/public.key\nEncryption key stored in:\n./data/oauth/encryption.key\n\n\n\nThe script will generate public and private keys, and an encryption key.\nThese keys are used by \nleague/oauth2-server\n\nas security settings for the OAuth2 server infrastructure.\n\n\nConfiguration\n\n\nThe OAuth2 server is configured by the \nauthentication\n configuration key in the\nPSR-11 container (e.g. \nzend-servicemanager\n).\n\n\nThe default values are:\n\n\nuse League\\OAuth2\\Server\\Grant;\n\nreturn [\n    'private_key'    => __DIR__ . '/../data/oauth/private.key',\n    'public_key'     => __DIR__ . '/../data/oauth/public.key',\n    'encryption_key' => require __DIR__ . '/../data/oauth/encryption.key',\n    'access_token_expire'  => 'P1D',\n    'refresh_token_expire' => 'P1M',\n    'auth_code_expire'     => 'PT10M',\n    'pdo' => [\n        'dsn'      => '',\n        'username' => '',\n        'password' => ''\n    ],\n\n    // Set value to null to disable a grant\n    'grants' => [\n        Grant\\ClientCredentialsGrant::class => Grant\\ClientCredentialsGrant::class,\n        Grant\\PasswordGrant::class          => Grant\\PasswordGrant::class,\n        Grant\\AuthCodeGrant::class          => Grant\\AuthCodeGrant::class,\n        Grant\\ImplicitGrant::class          => Grant\\ImplicitGrant::class,\n        Grant\\RefreshTokenGrant::class      => Grant\\RefreshTokenGrant::class\n    ],\n];\n\n\n\nThe \nprivate_key\n and \npublic_key\n values contains the paths to the previous\ngenerated pair of keys. The \nencryption_key\n contains the encryption key value\nas a string, as stored in the \ndata/oauth/encryption.key\n file.\n\n\nThe \naccess_token_expire\n value is the time-to-live (TTL) value of the access\ntoken. The time period is represented using the \nDateInterval\n\nformat in PHP.  The default value is \nP1D\n (1 day).\n\n\nThe \nrefresh_token_expire\n value is the TTL used for the refresh token. The\ndefault value is 1 month.\n\n\nThe \nauth_code_expire\n value is the TTL of the authentication code, used in\nthe \nauthorization code grant\n\nscenario. The default value is 10 minutes.\n\n\nThe \npdo\n value is for the PDO database configuration. Here we need to insert\nthe parameters to access the OAuth2 database. These parameters are the \ndsn\n,\nthe \nusername\n, and the \npassword\n, if required. The SQL structure of this\ndatabase is stored in the \ndata/oauth2.sql\n\nfile.\n\n\nIf you already have a PDO service configured, you can instead pass the service\nname to the \npdo\n key as follows:\n\n\nreturn [\n    'pdo' => 'myServiceName',\n];\n\n\n\nThe \ngrants\n array is for enabling/disabling grants. By default, all the supported\ngrants are configured to be available. If you would like to disable any of the\nsupplied grants, change the value for the grant to \nnull\n. Additionally,\nyou can extend this array to add your own custom grants.\n\n\nYou need to provide an OAuth2 database yourself, or generate a \nSQLite\n\ndatabase with the following command (using \nsqlite3\n for GNU/Linux):\n\n\n$ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2.sql\n\n\n\nYou can also create some testing values using the \ndata/oauth2_test.sql\n file:\n\n\n$ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2_test.sql\n\n\n\nThese commands will insert the following testing values:\n\n\n\n\na client \nclient_test\n with secret \ntest\n, used for \nclient_credentials\n\n  and the \npassword\n grant type.\n\n\na client \nclient_test2\n with secret \ntest\n, used for \nauthorization code\n\n  and \nimplicit\n grant type.\n\n\na user \nuser_test\n with password \ntest\n.\n\n\na \ntest\n scope.\n\n\n\n\nFor security reason, the client \nsecret\n and the user \npassword\n are stored\nusing the \nbcrypt\n algorithm as used by the \npassword_hash\n\nfunction.\n\n\nConfigure OAuth2 routes\n\n\nAs the final step, in order to use the OAuth2 server you need to configure the routes\nfor the \ntoken endpoint\n and \nauthorization\n.\n\n\nYou can read how add the \ntoken endpoint\n and the \nauthorization\n routes in\nthe \nImplement an authorization server\n section.",
            "title": "Introduction"
        },
        {
            "location": "/v1/intro/#zendframeworkzend-expressive-authentication-oauth2",
            "text": "This component provides  OAuth2  (server) authentication\nfor  Expressive  and PSR-7 / PSR-15 \napplications. It implements  Zend\\Expressive\\Authentication\\AuthenticationInterface ,\nand it can be used as an adapter for  zend-expressive-authentication .  This library uses the  league/oauth2-server \npackage for implementing the OAuth2 server.  If you need an introduction to OAuth2, you can read the following references:   OAuth2 documentation \n  from the Apigility project.  An Introduction to OAuth 2 \n  by DigitalOcean.  The  OAuth2 specification  itself, via its official\n  website.",
            "title": "zendframework/zend-expressive-authentication-oauth2"
        },
        {
            "location": "/v1/intro/#installation",
            "text": "In order to implement the OAuth2 server, we first need to configure it. The\nfirst step is to generate new cryptographic keys. We need to execute the script ./vendor/bin/generate-oauth2-keys  in order to generate these keys.  $ ./vendor/bin/generate-oauth2-keys  This script will store the keys in the application's  data  folder if found:  Private key stored in:\n./data/oauth/private.key\nPublic key stored in:\n./data/oauth/public.key\nEncryption key stored in:\n./data/oauth/encryption.key  The script will generate public and private keys, and an encryption key.\nThese keys are used by  league/oauth2-server \nas security settings for the OAuth2 server infrastructure.",
            "title": "Installation"
        },
        {
            "location": "/v1/intro/#configuration",
            "text": "The OAuth2 server is configured by the  authentication  configuration key in the\nPSR-11 container (e.g.  zend-servicemanager ).  The default values are:  use League\\OAuth2\\Server\\Grant;\n\nreturn [\n    'private_key'    => __DIR__ . '/../data/oauth/private.key',\n    'public_key'     => __DIR__ . '/../data/oauth/public.key',\n    'encryption_key' => require __DIR__ . '/../data/oauth/encryption.key',\n    'access_token_expire'  => 'P1D',\n    'refresh_token_expire' => 'P1M',\n    'auth_code_expire'     => 'PT10M',\n    'pdo' => [\n        'dsn'      => '',\n        'username' => '',\n        'password' => ''\n    ],\n\n    // Set value to null to disable a grant\n    'grants' => [\n        Grant\\ClientCredentialsGrant::class => Grant\\ClientCredentialsGrant::class,\n        Grant\\PasswordGrant::class          => Grant\\PasswordGrant::class,\n        Grant\\AuthCodeGrant::class          => Grant\\AuthCodeGrant::class,\n        Grant\\ImplicitGrant::class          => Grant\\ImplicitGrant::class,\n        Grant\\RefreshTokenGrant::class      => Grant\\RefreshTokenGrant::class\n    ],\n];  The  private_key  and  public_key  values contains the paths to the previous\ngenerated pair of keys. The  encryption_key  contains the encryption key value\nas a string, as stored in the  data/oauth/encryption.key  file.  The  access_token_expire  value is the time-to-live (TTL) value of the access\ntoken. The time period is represented using the  DateInterval \nformat in PHP.  The default value is  P1D  (1 day).  The  refresh_token_expire  value is the TTL used for the refresh token. The\ndefault value is 1 month.  The  auth_code_expire  value is the TTL of the authentication code, used in\nthe  authorization code grant \nscenario. The default value is 10 minutes.  The  pdo  value is for the PDO database configuration. Here we need to insert\nthe parameters to access the OAuth2 database. These parameters are the  dsn ,\nthe  username , and the  password , if required. The SQL structure of this\ndatabase is stored in the  data/oauth2.sql \nfile.  If you already have a PDO service configured, you can instead pass the service\nname to the  pdo  key as follows:  return [\n    'pdo' => 'myServiceName',\n];  The  grants  array is for enabling/disabling grants. By default, all the supported\ngrants are configured to be available. If you would like to disable any of the\nsupplied grants, change the value for the grant to  null . Additionally,\nyou can extend this array to add your own custom grants.  You need to provide an OAuth2 database yourself, or generate a  SQLite \ndatabase with the following command (using  sqlite3  for GNU/Linux):  $ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2.sql  You can also create some testing values using the  data/oauth2_test.sql  file:  $ sqlite3 data/oauth2.sqlite < vendor/zendframework/zend-expressive-authentication-oauth2/data/oauth2_test.sql  These commands will insert the following testing values:   a client  client_test  with secret  test , used for  client_credentials \n  and the  password  grant type.  a client  client_test2  with secret  test , used for  authorization code \n  and  implicit  grant type.  a user  user_test  with password  test .  a  test  scope.   For security reason, the client  secret  and the user  password  are stored\nusing the  bcrypt  algorithm as used by the  password_hash \nfunction.",
            "title": "Configuration"
        },
        {
            "location": "/v1/intro/#configure-oauth2-routes",
            "text": "As the final step, in order to use the OAuth2 server you need to configure the routes\nfor the  token endpoint  and  authorization .  You can read how add the  token endpoint  and the  authorization  routes in\nthe  Implement an authorization server  section.",
            "title": "Configure OAuth2 routes"
        },
        {
            "location": "/v1/usage/",
            "text": "Usage\n\n\nIf you successfully configured the OAuth2 server as detailed in the\n\ninstallation\n section, you can request an access token using the\nOAuth2 server route you \ndefined\n\n(e.g. \n/oauth\n).\n\n\nYou can require an access token using one of the following scenarios:\n\n\n\n\nclient credentials\n;\n\n\npassword\n;\n\n\nauthorization code\n;\n\n\nimplicit\n;\n\n\nrefresh token\n.\n\n\n\n\nAuthenticate a middleware\n\n\nThis library uses the authentication abstraction of the \nZend\\Expressive\\Authentication\\AuthenticationMiddleware\n\nclass provided by \nzend-expressive-authentication\n.\n\n\nIn order to use OAuth2, we need to configure the service\n\nZend\\Expressive\\Authentication\\AuthenticationInterface\n to resolve to\n\nZend\\Expressive\\Authentication\\OAuth2\\OAuth2Adapter\n. This can be achieved\nusing the following configuration:\n\n\nuse Zend\\Expressive\\Authentication;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            Authentication\\AuthenticationInterface::class => Authentication\\OAuth2\\OAuth2Adapter::class,\n        ],\n    ],\n];\n\n\n\nThe previous configuration will instruct \nzend-expressive-authentication\n to use\nthe OAuth2 adapter provided in this package. (Unlike other adapters, this\nadapter does not require a \nZend\\Expressive\\Authentication\\UserRepositoryInterface\n;\nthe OAuth2 database with user and client credentials is managed by the component\nitself.)\n\n\nWhen the service alias is configured, you can immediately begin authenticating\nyour application/API by adding the \nAuthenticationMiddleware\n to either your\napplication or route-specific middleware pipeline. For instance, using an\n\nExpressive\n application, you\ncould add it to a specific route, as follows:\n\n\n$app->post('/api/users', [\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Action\\AddUserAction::class,\n], 'api.add.user');\n\n\n\nProviding an authorization server\n\n\nSee the chapter \nAuthorization server\n for details on how\nto implement this.",
            "title": "Usage"
        },
        {
            "location": "/v1/usage/#usage",
            "text": "If you successfully configured the OAuth2 server as detailed in the installation  section, you can request an access token using the\nOAuth2 server route you  defined \n(e.g.  /oauth ).  You can require an access token using one of the following scenarios:   client credentials ;  password ;  authorization code ;  implicit ;  refresh token .",
            "title": "Usage"
        },
        {
            "location": "/v1/usage/#authenticate-a-middleware",
            "text": "This library uses the authentication abstraction of the  Zend\\Expressive\\Authentication\\AuthenticationMiddleware \nclass provided by  zend-expressive-authentication .  In order to use OAuth2, we need to configure the service Zend\\Expressive\\Authentication\\AuthenticationInterface  to resolve to Zend\\Expressive\\Authentication\\OAuth2\\OAuth2Adapter . This can be achieved\nusing the following configuration:  use Zend\\Expressive\\Authentication;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            Authentication\\AuthenticationInterface::class => Authentication\\OAuth2\\OAuth2Adapter::class,\n        ],\n    ],\n];  The previous configuration will instruct  zend-expressive-authentication  to use\nthe OAuth2 adapter provided in this package. (Unlike other adapters, this\nadapter does not require a  Zend\\Expressive\\Authentication\\UserRepositoryInterface ;\nthe OAuth2 database with user and client credentials is managed by the component\nitself.)  When the service alias is configured, you can immediately begin authenticating\nyour application/API by adding the  AuthenticationMiddleware  to either your\napplication or route-specific middleware pipeline. For instance, using an Expressive  application, you\ncould add it to a specific route, as follows:  $app->post('/api/users', [\n    Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class,\n    App\\Action\\AddUserAction::class,\n], 'api.add.user');",
            "title": "Authenticate a middleware"
        },
        {
            "location": "/v1/usage/#providing-an-authorization-server",
            "text": "See the chapter  Authorization server  for details on how\nto implement this.",
            "title": "Providing an authorization server"
        },
        {
            "location": "/v1/authorization-server/",
            "text": "Implement an authorization server\n\n\nThis library provides the basics for implementing an authorization server\nfor your application.\n\n\nSince there are authorization flows that require user interaction,\n\nyour application is expected to provide the middleware to handle this\n.\n\n\nAdd the token endpoint\n\n\nAdding the token endpoint involves routing to the provided\n\nZend\\Expressive\\Authentication\\OAuth2\\TokenEndpointHandler\n.\n\n\nThis endpoint \nMUST\n accept \nPOST\n requests.\n\n\nFor example:\n\n\nuse Zend\\Expressive\\Authentication\\OAuth2;\n\n$app->post('/oauth2/token', OAuth2\\TokenEndpointHandler::class);\n\n\n\nAdd the authorization endpoint\n\n\nThe authorization endpoint is the URL to which the client redirects\nto obtain an access token or authorization code.\n\n\nThis endpoint \nMUST\n accept \nGET\n requests and should:\n\n\n\n\n\n\nValidate the request (especially for a valid client id and redirect url).\n\n\n\n\n\n\nMake sure the user is authenticated (for example, by showing a login\n  prompt if needed).\n\n\n\n\n\n\nOptionally, request the user's consent to grant access to the client.\n\n\n\n\n\n\nRedirect to a specified url of the client with success or error information.\n\n\n\n\n\n\nThe first and the last items are provided by this library.\n\n\nFor example, to add the authorization endpoint, you can declare a middleware\npipeline for the route as follows:\n\n\nuse Zend\\Expressive\\Authentication\\OAuth2;\nuse Zend\\Expressive\\Session\\SessionMiddleware;\n\n$app->route('/oauth2/authorize', [\n    SessionMiddleware::class,\n\n    OAuth2\\AuthorizationMiddleware::class,\n\n    // The following middleware is provided by your application (see below):\n    App\\OAuthAuthorizationMiddleware::class,\n\n    OAuth2\\AuthorizationHandler::class\n], ['GET', 'POST']);\n\n\n\nIn your \nApp\\OAuthAuthorizationMiddleware\n, you'll have access to the\n\nLeague\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest\n via the PSR-7 request.\nYour middleware should populate the \nAuthorizationRequest\n's user entity via its\n\nsetUser()\n method, and the user's consent decision via the\n\nsetAuthorizationApproved()\nmethod.\n\n\nAs an example:\n\n\nnamespace App;\n\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest;\nuse Zend\\Expressive\\Authentication\\UserInterface;\n\nclass OAuthAuthorizationMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Assume a middleware handled the authentication check and\n        // populates the user object, which also implements the\n        // OAuth2 UserEntityInterface\n        $user = $request->getAttribute(UserInterface::class);\n\n        // Assume the SessionMiddleware handles and populates a session\n        // container\n        $session = $request->getAttribute('session');\n\n        // This is populated by the previous middleware:\n        /** @var AuthorizationRequest $authRequest */\n        $authRequest = $request->getAttribute(AuthorizationRequest::class);\n\n        // The user is authenticated:\n        if ($user) {\n            $authRequest->setUser($user);\n\n            // This assumes all clients are trusted, but you could\n            // handle consent here, or within the next middleware\n            // as needed.\n            $authRequest->setAuthorizationApproved(true);\n\n            return $handler->handle($request);\n        }\n\n        // The user is not authenticated, show login form ...\n\n        // Store the auth request state\n        // NOTE: Do not attempt to serialize or store the authorization\n        // request object. Store the query parameters instead and redirect\n        // with these to this endpoint again to replay the request.\n        $session['oauth2_request_params'] = $request->getQueryParams();\n\n        return new RedirectResponse('/oauth2/login');\n    }\n}",
            "title": "Authorization server"
        },
        {
            "location": "/v1/authorization-server/#implement-an-authorization-server",
            "text": "This library provides the basics for implementing an authorization server\nfor your application.  Since there are authorization flows that require user interaction, your application is expected to provide the middleware to handle this .",
            "title": "Implement an authorization server"
        },
        {
            "location": "/v1/authorization-server/#add-the-token-endpoint",
            "text": "Adding the token endpoint involves routing to the provided Zend\\Expressive\\Authentication\\OAuth2\\TokenEndpointHandler .  This endpoint  MUST  accept  POST  requests.  For example:  use Zend\\Expressive\\Authentication\\OAuth2;\n\n$app->post('/oauth2/token', OAuth2\\TokenEndpointHandler::class);",
            "title": "Add the token endpoint"
        },
        {
            "location": "/v1/authorization-server/#add-the-authorization-endpoint",
            "text": "The authorization endpoint is the URL to which the client redirects\nto obtain an access token or authorization code.  This endpoint  MUST  accept  GET  requests and should:    Validate the request (especially for a valid client id and redirect url).    Make sure the user is authenticated (for example, by showing a login\n  prompt if needed).    Optionally, request the user's consent to grant access to the client.    Redirect to a specified url of the client with success or error information.    The first and the last items are provided by this library.  For example, to add the authorization endpoint, you can declare a middleware\npipeline for the route as follows:  use Zend\\Expressive\\Authentication\\OAuth2;\nuse Zend\\Expressive\\Session\\SessionMiddleware;\n\n$app->route('/oauth2/authorize', [\n    SessionMiddleware::class,\n\n    OAuth2\\AuthorizationMiddleware::class,\n\n    // The following middleware is provided by your application (see below):\n    App\\OAuthAuthorizationMiddleware::class,\n\n    OAuth2\\AuthorizationHandler::class\n], ['GET', 'POST']);  In your  App\\OAuthAuthorizationMiddleware , you'll have access to the League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest  via the PSR-7 request.\nYour middleware should populate the  AuthorizationRequest 's user entity via its setUser()  method, and the user's consent decision via the setAuthorizationApproved() method.  As an example:  namespace App;\n\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse League\\OAuth2\\Server\\RequestTypes\\AuthorizationRequest;\nuse Zend\\Expressive\\Authentication\\UserInterface;\n\nclass OAuthAuthorizationMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Assume a middleware handled the authentication check and\n        // populates the user object, which also implements the\n        // OAuth2 UserEntityInterface\n        $user = $request->getAttribute(UserInterface::class);\n\n        // Assume the SessionMiddleware handles and populates a session\n        // container\n        $session = $request->getAttribute('session');\n\n        // This is populated by the previous middleware:\n        /** @var AuthorizationRequest $authRequest */\n        $authRequest = $request->getAttribute(AuthorizationRequest::class);\n\n        // The user is authenticated:\n        if ($user) {\n            $authRequest->setUser($user);\n\n            // This assumes all clients are trusted, but you could\n            // handle consent here, or within the next middleware\n            // as needed.\n            $authRequest->setAuthorizationApproved(true);\n\n            return $handler->handle($request);\n        }\n\n        // The user is not authenticated, show login form ...\n\n        // Store the auth request state\n        // NOTE: Do not attempt to serialize or store the authorization\n        // request object. Store the query parameters instead and redirect\n        // with these to this endpoint again to replay the request.\n        $session['oauth2_request_params'] = $request->getQueryParams();\n\n        return new RedirectResponse('/oauth2/login');\n    }\n}",
            "title": "Add the authorization endpoint"
        },
        {
            "location": "/v1/authenticated-user/",
            "text": "Authenticated user\n\n\nOnce the user is authenticated, zend-expressive-authentication-oauth2 stores the\nuser's authorization details in a PSR-7 attribute under the name\n\nZend\\Expressive\\Authentication\\UserInterface\n, using an object implementing the\n\ninterface of the same name\n.\n\n\nThis object contains all information discovered and/or generated by\n\nthephpleage/oauth2-server\n, including the\nfollowing data:\n\n\n[\n    'oauth_user_id'         => /* user's identifier (string) */,\n    'oauth_client_id'       => /* the client id (string) */,\n    'oauth_access_token_id' => /* the access token id (string) */,\n    'oauth_scopes'          => /* the scopes (mixed, usually an array) */\n]\n\n\n\nYou may retrieve all of these values using the \ngetDetails()\n method, or\nindividually using the \ngetDetail($name)\n method, of the user instance. As an\nexample:\n\n\n$user->getDetails(); // returns all the values, as array\n\n// Retrieves only the oauth_user_id value, using a default of boolean false:\n$userId = $user->getDetail('oauth_user_id', false);\nif (false !== $userId) {\n    printf(\"The user ID is %s\", $userId);\n}\n\n\n\nIf you want to retrieve the identity of the user (or the client), you can also\nuse the \ngetIdentity()\n method. This method returns the user's ID if it is\nnot null; otherwise it returns the client's ID.\n\n\nThe \ngetRoles()\n method of the user instance always returns an empty array.\n\n\nCustomize the user instance\n\n\nIf you wish to provide a custom \nZend\\Expressive\\Authentication\\UserInterface\n\nimplementation, you will need to provide:\n\n\n\n\na custom implementation of the the interface.\n\n\na factory capable of generating instances of that implementation.\n\n\na DI factory for generating the previous factory.\n\n\nconfiguration wiring the \nUserInterface\n service to your factory.\n\n\n\n\nThe factory noted in the second step should be a callable with the following\nsignature:\n\n\nfunction (\n    string $identity,\n    array $roles = [],\n    array $details = []\n) : Zend\\Expressive\\Authentication\\UserInterface\n\n\n\nAs an example of the factory in the third point, you will create a standard DI\nfactory to return it. It could, for instance, compose a database adapter to pull\ninformation and create your custom user implementation:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Db\\Adapter\\AdapterInterface as DbAdapter;\nuse Zend\\Expressive\\Authentication\\UserInterface;\n\nclass CustomUserFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $db = $container->get(DbAdapter::class);\n        return function (string $identity, array $roles = [], array $details = []) use ($db) : UserInterface {\n            // get some data from $db\n            // return a new instance\n            return new MyCustomUserType(/* ... */);\n        });\n    }\n}\n\n\n\nYou will then need to wire this factory to the \nUserInterface\n service,\nper the following example:\n\n\n// config/autoload/custom-user.local.php\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UserInterface::class => CustomUserFactory::class,\n        ],\n    ],\n];",
            "title": "Authenticated user"
        },
        {
            "location": "/v1/authenticated-user/#authenticated-user",
            "text": "Once the user is authenticated, zend-expressive-authentication-oauth2 stores the\nuser's authorization details in a PSR-7 attribute under the name Zend\\Expressive\\Authentication\\UserInterface , using an object implementing the interface of the same name .  This object contains all information discovered and/or generated by thephpleage/oauth2-server , including the\nfollowing data:  [\n    'oauth_user_id'         => /* user's identifier (string) */,\n    'oauth_client_id'       => /* the client id (string) */,\n    'oauth_access_token_id' => /* the access token id (string) */,\n    'oauth_scopes'          => /* the scopes (mixed, usually an array) */\n]  You may retrieve all of these values using the  getDetails()  method, or\nindividually using the  getDetail($name)  method, of the user instance. As an\nexample:  $user->getDetails(); // returns all the values, as array\n\n// Retrieves only the oauth_user_id value, using a default of boolean false:\n$userId = $user->getDetail('oauth_user_id', false);\nif (false !== $userId) {\n    printf(\"The user ID is %s\", $userId);\n}  If you want to retrieve the identity of the user (or the client), you can also\nuse the  getIdentity()  method. This method returns the user's ID if it is\nnot null; otherwise it returns the client's ID.  The  getRoles()  method of the user instance always returns an empty array.",
            "title": "Authenticated user"
        },
        {
            "location": "/v1/authenticated-user/#customize-the-user-instance",
            "text": "If you wish to provide a custom  Zend\\Expressive\\Authentication\\UserInterface \nimplementation, you will need to provide:   a custom implementation of the the interface.  a factory capable of generating instances of that implementation.  a DI factory for generating the previous factory.  configuration wiring the  UserInterface  service to your factory.   The factory noted in the second step should be a callable with the following\nsignature:  function (\n    string $identity,\n    array $roles = [],\n    array $details = []\n) : Zend\\Expressive\\Authentication\\UserInterface  As an example of the factory in the third point, you will create a standard DI\nfactory to return it. It could, for instance, compose a database adapter to pull\ninformation and create your custom user implementation:  use Psr\\Container\\ContainerInterface;\nuse Zend\\Db\\Adapter\\AdapterInterface as DbAdapter;\nuse Zend\\Expressive\\Authentication\\UserInterface;\n\nclass CustomUserFactory\n{\n    public function __invoke(ContainerInterface $container) : callable\n    {\n        $db = $container->get(DbAdapter::class);\n        return function (string $identity, array $roles = [], array $details = []) use ($db) : UserInterface {\n            // get some data from $db\n            // return a new instance\n            return new MyCustomUserType(/* ... */);\n        });\n    }\n}  You will then need to wire this factory to the  UserInterface  service,\nper the following example:  // config/autoload/custom-user.local.php\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UserInterface::class => CustomUserFactory::class,\n        ],\n    ],\n];",
            "title": "Customize the user instance"
        },
        {
            "location": "/v1/grant/client_credentials/",
            "text": "Client credentials\n\n\nThe client credentials grant is used in machine-to-machine scenarios. For\nexample, you would use it with a client making API requests that do not require\na user's permission.\n\n\nThe client sends a \nPOST\n request with the following body parameters to the\nauthorization server:\n\n\n\n\ngrant_type\n = client_credentials.\n\n\nclient_id\n with the client's ID.\n\n\nclient_secret\n with the client's secret.\n\n\nscope\n with a space-delimited list of requested scope permissions.\n\n\n\n\nThe authorization server responds with a JSON payload as follows:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe values returned are as follows:\n\n\n\n\nThe \ntoken_type\n is the type of generated token (here, and generally, Bearer).\n\n\nexpires_in\n is an integer representing the time-to-live (in seconds) of the\n  access token.\n\n\nThe \naccess_token\n contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n  \nAuthorization\n request HTTP header in subsequent requests.",
            "title": "Client credentials"
        },
        {
            "location": "/v1/grant/client_credentials/#client-credentials",
            "text": "The client credentials grant is used in machine-to-machine scenarios. For\nexample, you would use it with a client making API requests that do not require\na user's permission.  The client sends a  POST  request with the following body parameters to the\nauthorization server:   grant_type  = client_credentials.  client_id  with the client's ID.  client_secret  with the client's secret.  scope  with a space-delimited list of requested scope permissions.   The authorization server responds with a JSON payload as follows:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The values returned are as follows:   The  token_type  is the type of generated token (here, and generally, Bearer).  expires_in  is an integer representing the time-to-live (in seconds) of the\n  access token.  The  access_token  contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n   Authorization  request HTTP header in subsequent requests.",
            "title": "Client credentials"
        },
        {
            "location": "/v1/grant/password/",
            "text": "Password\n\n\nThis use case allows authentication to an API using the user's credentials\n(generally a username and password).  The typical scenario includes a \"Login\"\nweb page that captures a username and password combination that is used to\nauthenticate against a first-party API. Password grant is only appropriate for\n\ntrusted clients\n. If you build your own website as a client of your API, then\nthis is a great way to handle logging in.\n\n\nThe client sends a POST request with following parameters:\n\n\n\n\ngrant_type\n = password.\n\n\nclient_id\n with the client\u2019s ID.\n\n\nclient_secret\n with the client\u2019s secret.\n\n\nscope\n with a space-delimited list of requested scope permissions.\n\n\nusername\n with the user\u2019s username.\n\n\npassword\n with the user\u2019s password.\n\n\n\n\nThe authorization server responds with a JSON as follows:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe \ntoken_type\n is the type of generated token (Bearer). The \nexpires_in\n is an\ninteger representing the TTL (in seconds) of the access token.  The\n\nrefresh_token\n a token that can be used to refresh the \naccess_token\n when\nexpired.  The \naccess_token\n contains a \nJWT\n signed with the authorization\nserver\u2019s private key. This token must be used in the \nAuthorization\n request\nHTTP header.",
            "title": "Password"
        },
        {
            "location": "/v1/grant/password/#password",
            "text": "This use case allows authentication to an API using the user's credentials\n(generally a username and password).  The typical scenario includes a \"Login\"\nweb page that captures a username and password combination that is used to\nauthenticate against a first-party API. Password grant is only appropriate for trusted clients . If you build your own website as a client of your API, then\nthis is a great way to handle logging in.  The client sends a POST request with following parameters:   grant_type  = password.  client_id  with the client\u2019s ID.  client_secret  with the client\u2019s secret.  scope  with a space-delimited list of requested scope permissions.  username  with the user\u2019s username.  password  with the user\u2019s password.   The authorization server responds with a JSON as follows:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The  token_type  is the type of generated token (Bearer). The  expires_in  is an\ninteger representing the TTL (in seconds) of the access token.  The refresh_token  a token that can be used to refresh the  access_token  when\nexpired.  The  access_token  contains a  JWT  signed with the authorization\nserver\u2019s private key. This token must be used in the  Authorization  request\nHTTP header.",
            "title": "Password"
        },
        {
            "location": "/v1/grant/auth_code/",
            "text": "Authorization code\n\n\nThe authorization code is used to authenticate a web application with a\nthird-party service (e.g., imagine you built a web application that needs to\nconsume the API of Facebook). You can authenticate your application using the\nthird-party server with a 4-step flow as illustrated in this diagram:\n\n\n\n\nThe web application sends a request (including the \nclient_id\n and the\n\nredirect_uri\n) to the authorization server asking for an authorization code (1).\nThe authorization server shows an allow/deny page to the end-user requesting\nauthorization for access. If the user clicks on \"Allow\", the server sends the\nauthorization code to the web application using the \nredirect_uri\n (2).\nThe web application can now perform a token request, passing the \nclient_id\n,\nthe \nredirect_uri\n, the \nclient_secret\n, and the authentication code to prove\nthat it is authorized to perform the request (3). The authorization server sends\nthe access token in the response if the request is valid (4).\n\n\nRequest the authorization code\n\n\nThe client sends the following parameters via query string arguments to the\nauthorization server:\n\n\n\n\nresponse_type\n = code.\n\n\nclient_id\n with the client identifer.\n\n\nredirect_uri\n with the URI to which to redirect the client following\n  successful authorization. This parameter is optional, but if it is not sent,\n  the user will be redirected to a default location on completion.\n\n\nscope\n with a space-delimited list of requested scope permissions.\n\n\nstate\n with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional, but highly recommended. You can store the value of the CSRF token in\n  the user\u2019s session to be validated in the next step.\n\n\n\n\nThe user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request they will be redirected to the\nredirect URI with the following parameters in the query string arguments:\n\n\n\n\ncode\n with the authorization code.\n\n\nstate\n with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.\n\n\n\n\nRequest the access token\n\n\nThe client sends a POST request to the authorization server with the following\nparameters:\n\n\n\n\ngrant_type\n = authorization_code.\n\n\nclient_id\n with the client\u2019s ID.\n\n\nclient_secret\n with the client\u2019s secret.\n\n\nredirect_uri\n with the previous client redirect URI.\n\n\ncode\n with the authorization code as returned in the authorization code\n  request (as detailed in the previous section).\n\n\n\n\nThe authorization server responds with a JSON payload similar to the following:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe values are as follows:\n\n\n\n\nThe \ntoken_type\n is the type of generated token (here, and generally,\n  \"Bearer\").\n\n\nThe \nexpires_in\n value is an integer representing the time-to-live (in\n  seconds) of the access token.\n\n\nThe \nrefresh_token\n is a token that can be used to refresh the \naccess_token\n\n  when expired.\n\n\nThe \naccess_token\n contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n  \nAuthorization\n request HTTP header on subsequent requests.",
            "title": "Authorization code"
        },
        {
            "location": "/v1/grant/auth_code/#authorization-code",
            "text": "The authorization code is used to authenticate a web application with a\nthird-party service (e.g., imagine you built a web application that needs to\nconsume the API of Facebook). You can authenticate your application using the\nthird-party server with a 4-step flow as illustrated in this diagram:   The web application sends a request (including the  client_id  and the redirect_uri ) to the authorization server asking for an authorization code (1).\nThe authorization server shows an allow/deny page to the end-user requesting\nauthorization for access. If the user clicks on \"Allow\", the server sends the\nauthorization code to the web application using the  redirect_uri  (2).\nThe web application can now perform a token request, passing the  client_id ,\nthe  redirect_uri , the  client_secret , and the authentication code to prove\nthat it is authorized to perform the request (3). The authorization server sends\nthe access token in the response if the request is valid (4).",
            "title": "Authorization code"
        },
        {
            "location": "/v1/grant/auth_code/#request-the-authorization-code",
            "text": "The client sends the following parameters via query string arguments to the\nauthorization server:   response_type  = code.  client_id  with the client identifer.  redirect_uri  with the URI to which to redirect the client following\n  successful authorization. This parameter is optional, but if it is not sent,\n  the user will be redirected to a default location on completion.  scope  with a space-delimited list of requested scope permissions.  state  with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional, but highly recommended. You can store the value of the CSRF token in\n  the user\u2019s session to be validated in the next step.   The user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request they will be redirected to the\nredirect URI with the following parameters in the query string arguments:   code  with the authorization code.  state  with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.",
            "title": "Request the authorization code"
        },
        {
            "location": "/v1/grant/auth_code/#request-the-access-token",
            "text": "The client sends a POST request to the authorization server with the following\nparameters:   grant_type  = authorization_code.  client_id  with the client\u2019s ID.  client_secret  with the client\u2019s secret.  redirect_uri  with the previous client redirect URI.  code  with the authorization code as returned in the authorization code\n  request (as detailed in the previous section).   The authorization server responds with a JSON payload similar to the following:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The values are as follows:   The  token_type  is the type of generated token (here, and generally,\n  \"Bearer\").  The  expires_in  value is an integer representing the time-to-live (in\n  seconds) of the access token.  The  refresh_token  is a token that can be used to refresh the  access_token \n  when expired.  The  access_token  contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n   Authorization  request HTTP header on subsequent requests.",
            "title": "Request the access token"
        },
        {
            "location": "/v1/grant/implicit/",
            "text": "Implicit grant\n\n\nThe implicit grant is similar to the \nauthorization code\n grant,\nwith two differences: it's used for user-agent-based clients (e.g. single page\napplications) that cannot store a secret in a secure way; additionally, the\nauthorization server returns the access token directly, without the need of an\nauthorization code.\n\n\nThe client sends the following parameter via a query string argument to the\nauthorization server:\n\n\n\n\nresponse_type\n = token.\n\n\nclient_id\n, with the client\u2019s ID.\n\n\nredirect_uri\n, with the URI to which to redirect the client after completing\n  authorization. This parameter is optional; if not provided, however, the user\n  will be redirected to a default location.\n\n\nscope\n, with a space-delimited list of requested scope permissions.\n\n\nstate\n, with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional but highly recommended. You can store the value of CSRF token in the\n  user\u2019s session to be validated in the next step.\n\n\n\n\nThe user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request, they will be redirected to the\nredirect URI with the following parameters in the query string arguments:\n\n\n\n\ntoken_type\n = Bearer.\n\n\nexpires_in\n, an integer representing the time-to-live (in seconds) of the\n  access token.\n\n\naccess_token\n, the access token represented by a JSON Web Token (JWT) signed\n  with the authorization server\u2019s private key.\n\n\nstate\n, with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.\n\n\n\n\nRefresh tokens are not to be issued for \nimplicit\n grants. This is a security\nrestriction coming from the OAuth2 specification, \nRFC 6749\n.",
            "title": "Implicit"
        },
        {
            "location": "/v1/grant/implicit/#implicit-grant",
            "text": "The implicit grant is similar to the  authorization code  grant,\nwith two differences: it's used for user-agent-based clients (e.g. single page\napplications) that cannot store a secret in a secure way; additionally, the\nauthorization server returns the access token directly, without the need of an\nauthorization code.  The client sends the following parameter via a query string argument to the\nauthorization server:   response_type  = token.  client_id , with the client\u2019s ID.  redirect_uri , with the URI to which to redirect the client after completing\n  authorization. This parameter is optional; if not provided, however, the user\n  will be redirected to a default location.  scope , with a space-delimited list of requested scope permissions.  state , with a Cross-Site Request Forgery (CSRF) token. This parameter is\n  optional but highly recommended. You can store the value of CSRF token in the\n  user\u2019s session to be validated in the next step.   The user will then be asked to login to the authorization server and approve the\nclient request. If the user approves the request, they will be redirected to the\nredirect URI with the following parameters in the query string arguments:   token_type  = Bearer.  expires_in , an integer representing the time-to-live (in seconds) of the\n  access token.  access_token , the access token represented by a JSON Web Token (JWT) signed\n  with the authorization server\u2019s private key.  state , with the CSRF parameter sent in the original request. You can compare\n  this value with the one stored in the user\u2019s session.   Refresh tokens are not to be issued for  implicit  grants. This is a security\nrestriction coming from the OAuth2 specification,  RFC 6749 .",
            "title": "Implicit grant"
        },
        {
            "location": "/v1/grant/refresh_token/",
            "text": "Refresh token\n\n\nThe OAuth2 framework provides the ability to \nrefresh\n the access token,\ngenerating a new one with a new lifetime. This action can be performed using\nthe \nrefresh_token\n value, if present in the access token response.\n\n\nTo request a token refresh, the client needs to send a \nPOST\n request with\nthe following parameters:\n\n\n\n\ngrant_type\n = refresh_token.\n\n\nrefresh_token\n with the refresh token.\n\n\nclient_id\n with the client\u2019s ID.\n\n\nclient_secret\n with the client\u2019s secret.\n\n\nscope\n with a space-delimited list of requested scope permissions. This is\n  optional; if not sent, the original scopes will be used. Otherwise you can\n  request a \nreduced\n scope; you may never \nexpand\n scope during a refresh\n  operation.\n\n\n\n\nThe authorization server responds with a JSON payload as follows:\n\n\n{\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}\n\n\n\nThe values are as follows:\n\n\n\n\nThe \ntoken_type\n is the type of generated token (here, and generally, Bearer).\n\n\nexpires_in\n is an integer representing the time-to-live (in seconds) of the\n  access token.\n\n\nThe \nrefresh_token\n a token that can be used to refresh the \naccess_token\n\n  when expired.\n\n\nThe \naccess_token\n contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n  \nAuthorization\n request HTTP header on all subsequent requests.",
            "title": "Refresh token"
        },
        {
            "location": "/v1/grant/refresh_token/#refresh-token",
            "text": "The OAuth2 framework provides the ability to  refresh  the access token,\ngenerating a new one with a new lifetime. This action can be performed using\nthe  refresh_token  value, if present in the access token response.  To request a token refresh, the client needs to send a  POST  request with\nthe following parameters:   grant_type  = refresh_token.  refresh_token  with the refresh token.  client_id  with the client\u2019s ID.  client_secret  with the client\u2019s secret.  scope  with a space-delimited list of requested scope permissions. This is\n  optional; if not sent, the original scopes will be used. Otherwise you can\n  request a  reduced  scope; you may never  expand  scope during a refresh\n  operation.   The authorization server responds with a JSON payload as follows:  {\n    \"token_type\" : \"Bearer\",\n    \"expires_in\" : \"3600\",\n    \"refresh_token\" : \"YWYwNjhmNmZmMDhmZjkyOGJj...\",\n    \"access_token\" : \"eyJ0eXAiOiJKV1Q...\"\n}  The values are as follows:   The  token_type  is the type of generated token (here, and generally, Bearer).  expires_in  is an integer representing the time-to-live (in seconds) of the\n  access token.  The  refresh_token  a token that can be used to refresh the  access_token \n  when expired.  The  access_token  contains a JSON Web Token (JWT) signed with the\n  authorization server\u2019s private key. This token must be used in the\n   Authorization  request HTTP header on all subsequent requests.",
            "title": "Refresh token"
        },
        {
            "location": "/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/intro/';\n  });",
            "title": "_introduction"
        },
        {
            "location": "/usage/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/usage/';\n  });",
            "title": "_usage"
        },
        {
            "location": "/authorization-server/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/authorization-server/';\n  });",
            "title": "_authorizationserver"
        },
        {
            "location": "/grant/client_credentials/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/client_credentials/';\n  });",
            "title": "_grant_clientcredentials"
        },
        {
            "location": "/grant/password/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/password/';\n  });",
            "title": "_grant_password"
        },
        {
            "location": "/grant/auth_code/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/auth_code/';\n  });",
            "title": "_grant_authcode"
        },
        {
            "location": "/grant/implicit/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/implicit/';\n  });",
            "title": "_grant_implicit"
        },
        {
            "location": "/grant/refresh_token/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive-authentication-oauth2/v1/grant/refresh_token/';\n  });",
            "title": "_grant_refreshtoken"
        }
    ]
}